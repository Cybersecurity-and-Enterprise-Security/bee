define listen_ip = "%s"
define if_wireguard = "wireguard0"
define connmark_local = 0x9
define mark_bees = 0x10

table inet bee_filter {
    set open_tcp_ports {
        typeof tcp dport
    }
    set open_udp_ports {
        typeof udp dport
    }

    chain bee_input {
        # We choose filter-1 as the priority to ensure these rules are applied
        # before the usual rules.
        type filter hook input priority filter - 1; policy accept;

        # Only apply our rules to the interface we are listening on
        ip daddr $listen_ip jump bee_block
    }
    chain bee_block {
        # Accept local connections
        ct state {established, related} ct mark $connmark_local counter accept

        # Keep discovered open TCP ports
        tcp dport @open_tcp_ports counter jump accept_local
        # Keep discovered open UDP ports
        udp dport @open_udp_ports counter jump accept_local

        # Send the rest to userspace, stop kernel processing
        # Conntrack does not see these packets despite them having passed through the first hook.
        meta l4proto {icmp, tcp, udp} counter log group 833 drop
    }

    chain local_output {
        type filter hook output priority filter - 1; policy accept;

        # Anything that does not come from the inject socket is considered a local connection
        meta mark != $mark_bees counter jump accept_local
    }

    chain bee_output {
        type filter hook output priority raw; policy accept;
        # Do not track packets to attacker, saves memory in conntrack table
        meta mark $mark_bees notrack
    }

    chain bee_prerouting {
        type filter hook prerouting priority raw; policy accept;
        # Do not track geneve packets for attacker
        iifname $if_wireguard notrack
    }

    # Jump target for local connections, i.e. those that should not be forwarded to the beehive
    chain accept_local {
        ct mark set $connmark_local accept
    }
}
